#include <assert.h>
#include <setjmp.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#include "CuTest.h"

/*
---------------------------------
Tests - Grant
---------------------------------
*/

void TestPawnMovement(CuTest* tc)
{
	char initial[2][8][8] = {
	{
	{'1',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	},
	{
	{'1',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	}
	};

	char expected[2][8][8] = {
	{
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{'1',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	},
	{
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{'1',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	}
	};

	compute('1', 0, 0, 1, 0, 0, initial);
	//compute('piecenumber', initialrow, initialcol, endrow, endcol, 0, initial);

	int i, j, k;
	
	//Compare result with expected chess board
	for (i = 0; i < 2; i++) {
		for (j = 0; j < 8; j++) {
			for (k = 0; k < 8; k++) {
				CuAssertTrue(tc, (initial[i][j][k] == expected[i][j][k]));
			}
		}
	}
}

/* WHEN MOVING PLAYER 2 PAWN FROM START, USE THE FUNCTION: "TESTPLAYER2PAWN...FROMSTART" */

void TestPlayer2PawnMovementForward(CuTest* tc)
{
	char initialg1[2][8][8] = {
	{
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{'1',' ',' ',' ',' ',' ',' ',' '},
	},
	{
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{'1',' ',' ',' ',' ',' ',' ',' '},
	}
	};

	char expectedg1[2][8][8] = {
	{
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{'1',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	},
	{
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{'1',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	}
	};

	compute('1', 7, 0, 6, 0, 0, initialg1);
	//compute('piecenumber', initialrow, initialcol, endrow, endcol, 0, initial);
	/* To test all possible outcomes: 
		endrow = initialrow - 1
		endcol = initialcol

		DONT FORGET TO CHANGE THE BOARDS APPROPIATELY!!
		*/

	int i, j, k;
	
	//Compare result with expected chess board
	for (i = 0; i < 2; i++) {
		for (j = 0; j < 8; j++) {
			for (k = 0; k < 8; k++) {
				CuAssertTrue(tc, (initialg1[i][j][k] == expectedg1[i][j][k]));
			}
		}
	}
}

void TestPlayer2PawnMovementForwardFromStart(CuTest* tc)
{
	char initialg11[2][8][8] = {
	{
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{'1',' ',' ',' ',' ',' ',' ',' '},
	},
	{
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{'1',' ',' ',' ',' ',' ',' ',' '},
	}
	};

	char expectedg11[2][8][8] = {
	{
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{'1',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	},
	{
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{'1',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	}
	};

	compute('1', 7, 0, 6, 0, 0, initialg11);
	//compute('piecenumber', initialrow, initialcol, endrow, endcol, 0, initial);

	int i, j, k;
	
	//Compare result with expected chess board
	for (i = 0; i < 2; i++) {
		for (j = 0; j < 8; j++) {
			for (k = 0; k < 8; k++) {
				CuAssertTrue(tc, (initialg11[i][j][k] == expectedg11[i][j][k]));
			}
		}
	}
}

void TestQueenMovementForward(CuTest* tc)
{
	char initialg2[2][8][8] = {
	{
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ','7',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	},
	{
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ','7',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	}
	};

	char expectedg2[2][8][8] = {
	{
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ','7',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	},
	{
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ','7',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	}
	};

	compute('7', 3, 3, 2, 3, 0, initialg2);
	//compute('piecenumber', initialrow, initialcol, endrow, endcol, 0, initial);
	/* To test all possible movements from initialg2, endrow = initialrow - x for [0 <= endrow <= 8], [x > 0] */

	int i, j, k;
	
	//Compare result with expected chess board
	for (i = 0; i < 2; i++) {
		for (j = 0; j < 8; j++) {
			for (k = 0; k < 8; k++) {
				CuAssertTrue(tc, (initialg2[i][j][k] == expectedg2[i][j][k]));
			}
		}
	}
}

void TestQueenMovementBackward(CuTest* tc)
{
	char initialg3[2][8][8] = {
	{
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ','7',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	},
	{
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ','7',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	}
	};

	char expectedg3[2][8][8] = {
	{
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ','7',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	},
	{
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ','7',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	}
	};

	compute('7', 3, 3, 4, 3, 0, initialg3);
	//compute('piecenumber', initialrow, initialcol, endrow, endcol, 0, initial);
	/* To test all possible movements from initialg3, endrow = initialrow + x for [0 <= endrow <= 8], [x > 0] */

	int i, j, k;
	
	//Compare result with expected chess board
	for (i = 0; i < 2; i++) {
		for (j = 0; j < 8; j++) {
			for (k = 0; k < 8; k++) {
				CuAssertTrue(tc, (initialg3[i][j][k] == expectedg3[i][j][k]));
			}
		}
	}
}

void TestQueenMovementRight(CuTest* tc)
{
	char initialg4[2][8][8] = {
	{
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ','7',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	},
	{
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ','7',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	}
	};

	char expectedg4[2][8][8] = {
	{
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ','7',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	},
	{
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ','7',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	}
	};

	compute('7', 3, 3, 3, 4, 0, initialg4);
	//compute('piecenumber', initialrow, initialcol, endrow, endcol, 0, initial);
	/* To test all possible movements from initialg4, endcol = initialcol + x for [0 <= endcol <= 8], [x > 0] */

	int i, j, k;
	
	//Compare result with expected chess board
	for (i = 0; i < 2; i++) {
		for (j = 0; j < 8; j++) {
			for (k = 0; k < 8; k++) {
				CuAssertTrue(tc, (initialg4[i][j][k] == expectedg4[i][j][k]));
			}
		}
	}
}

void TestQueenMovementLeft(CuTest* tc)
{
	char initialg5[2][8][8] = {
	{
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ','7',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	},
	{
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ','7',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	}
	};

	char expectedg5[2][8][8] = {
	{
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ','7',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	},
	{
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ','7',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	}
	};

	compute('7', 3, 3, 3, 2, 0, initialg5);
	//compute('piecenumber', initialrow, initialcol, endrow, endcol, 0, initial);
	/* To test all possible movements from initialg5, endcol = initialcol - x for [0 <= endcol <= 8], [x > 0] */

	int i, j, k;
	
	//Compare result with expected chess board
	for (i = 0; i < 2; i++) {
		for (j = 0; j < 8; j++) {
			for (k = 0; k < 8; k++) {
				CuAssertTrue(tc, (initialg5[i][j][k] == expectedg5[i][j][k]));
			}
		}
	}
}

void TestQueenMovementDiagonalBR(CuTest* tc)
{
	char initialg6[2][8][8] = {
	{
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ','7',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	},
	{
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ','7',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	}
	};

	char expectedg6[2][8][8] = {
	{
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ','7',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	},
	{
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ','7',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	}
	};

	compute('7', 3, 3, 4, 4, 0, initialg6);
	//compute('piecenumber', initialrow, initialcol, endrow, endcol, 0, initial);
	/* To test all possible movements from initialg6 
		endrow = initialrow + x for [0 <= endrow <= 8], [x > 0] 
		endcol = initialcol + x for [0 <= endcol <= 8], [x > 0]
		*/

	int i, j, k;
	
	//Compare result with expected chess board
	for (i = 0; i < 2; i++) {
		for (j = 0; j < 8; j++) {
			for (k = 0; k < 8; k++) {
				CuAssertTrue(tc, (initialg6[i][j][k] == expectedg6[i][j][k]));
			}
		}
	}
}

void TestQueenMovementDiagonalBL(CuTest* tc)
{
	char initialg7[2][8][8] = {
	{
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ','7',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	},
	{
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ','7',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	}
	};

	char expectedg7[2][8][8] = {
	{
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ','7',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	},
	{
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ','7',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	}
	};

	compute('7', 3, 3, 4, 2, 0, initialg7);
	//compute('piecenumber', initialrow, initialcol, endrow, endcol, 0, initial);
	/* To test all possible movements from initialg7 
		endrow = initialrow + x for [0 <= endrow <= 8], [x > 0] 
		endcol = initialcol - x for [0 <= endcol <= 8], [x > 0]
		*/

	int i, j, k;
	
	//Compare result with expected chess board
	for (i = 0; i < 2; i++) {
		for (j = 0; j < 8; j++) {
			for (k = 0; k < 8; k++) {
				CuAssertTrue(tc, (initialg7[i][j][k] == expectedg7[i][j][k]));
			}
		}
	}
}

void TestQueenMovementDiagonalFL(CuTest* tc)
{
	char initialg8[2][8][8] = {
	{
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ','7',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	},
	{
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ','7',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	}
	};

	char expectedg8[2][8][8] = {
	{
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ','7',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	},
	{
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ','7',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	}
	};

	compute('7', 3, 3, 2, 2, 0, initialg8);
	//compute('piecenumber', initialrow, initialcol, endrow, endcol, 0, initial);
	/* To test all possible movements from initialg8 
		endrow = initialrow - x for [0 <= endrow <= 8], [x > 0] 
		endcol = initialcol - x for [0 <= endcol <= 8], [x > 0]
		*/

	int i, j, k;
	
	//Compare result with expected chess board
	for (i = 0; i < 2; i++) {
		for (j = 0; j < 8; j++) {
			for (k = 0; k < 8; k++) {
				CuAssertTrue(tc, (initialg8[i][j][k] == expectedg8[i][j][k]));
			}
		}
	}
}

void TestQueenMovementDiagonalFR(CuTest* tc)
{
	char initialg9[2][8][8] = {
	{
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ','7',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	},
	{
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ','7',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	}
	};

	char expectedg9[2][8][8] = {
	{
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ','7',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	},
	{
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ','7',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' '},
	}
	};

	compute('7', 3, 3, 2, 4, 0, initialg9);
	//compute('piecenumber', initialrow, initialcol, endrow, endcol, 0, initial);
	/* To test all possible movements from initialg9 
		endrow = initialrow - x for [0 <= endrow <= 8], [x > 0] 
		endcol = initialcol + x for [0 <= endcol <= 8], [x > 0]
		*/

	int i, j, k;
	
	//Compare result with expected chess board
	for (i = 0; i < 2; i++) {
		for (j = 0; j < 8; j++) {
			for (k = 0; k < 8; k++) {
				CuAssertTrue(tc, (initialg9[i][j][k] == expectedg9[i][j][k]));
			}
		}
	}
}



/*
---------------------------------
Tests - Matthew
---------------------------------
*/



/*
---------------------------------
Tests - Zachary
---------------------------------
*/



/*
---------------------------------
Tests - Gavin
---------------------------------
*/



/*
---------------------------------
Compile Test Suite
---------------------------------
*/

CuSuite* CuGetSuite(void)
{
	CuSuite* suite = CuSuiteNew();

	//Unit Tests - Grant
	SUITE_ADD_TEST(suite, TestPawnMovement);

	
	//Unit Tests - Matthew

	
	//Unit Tests - Zachary

	
	//Unit Tests - Gavin
	SUITE_ADD_TEST(suite, TestPlayer2PawnMovementForward);
	SUITE_ADD_TEST(suite, TestQueenMovementForward);
	SUITE_ADD_TEST(suite, TestQueenMovementBackward);
	SUITE_ADD_TEST(suite, TestQueenMovementRight);
	SUITE_ADD_TEST(suite, TestQueenMovementLeft);
	SUITE_ADD_TEST(suite, TestQueenMovementDiagonalBR);
	SUITE_ADD_TEST(suite, TestQueenMovementDiagonalBL);
	SUITE_ADD_TEST(suite, TestQueenMovementDiagonalFL);
	SUITE_ADD_TEST(suite, TestQueenMovementDiagonalFR);

	return suite;
}
